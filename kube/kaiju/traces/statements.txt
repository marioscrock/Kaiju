#name:COUNT TRACES,listener:simple=select count(*) from Span(operationName != 'HTTP GET /debug/vars')#unique(traceIdHigh, traceIdLow) output last every 1 min
#Assumes operationName are unique
name:Table MeanDurationPerOperation,listener:none=create table MeanDurationPerOperation (operationName string primary key, meanDuration double, m2 double, counter long)
name:Update MeanDurationPerOperation,listener:none=on Span as s merge MeanDurationPerOperation m where s.operationName = m.operationName when matched and counter <= 100000 then update set counter = (initial.counter + 1), meanDuration = (initial.meanDuration + ((s.duration - initial.meanDuration)/counter)), m2 = (initial.m2 + (s.duration - meanDuration)*(s.duration - initial.meanDuration)) when matched and counter > 100000 then update set counter = 1, meanDuration = s.duration, m2 = 0 when not matched then insert select s.operationName as operationName, s.duration as meanDuration, 0 as m2, 1 as counter
name:HLEvent for spans with anomalous latency (diff>3*stddev),listener:none=insert into Event select java.time.Instant.now().toEpochMilli() as timestamp, new {traceId=eps.EventToJsonConverter.traceIdToHex(s.traceIdHigh, s.traceIdLow), spanId=Long.toHexString(s.spanId), operationName=s.operationName, duration=s.duration} as payload, new {serviceName=p.serviceName, startTime=s.startTime, node=s.getTags().firstOf(t => t.key = 'kube.node_name').getVStr(), pod=s.getTags().firstOf(t => t.key = 'kube.pod_name').getVStr(), namespace=s.getTags().firstOf(t => t.key = 'kube.pod_namespace').getVStr()} as context from Batch[select process as p, * from spans as s] where (s.duration - MeanDurationPerOperation[s.operationName].meanDuration) > 3 * java.lang.Math.sqrt((MeanDurationPerOperation[s.operationName].m2) / (MeanDurationPerOperation[s.operationName].counter))
